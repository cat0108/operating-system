# lab0.5

1. **bootloader**：在操作系统执行之前，把操作系统加载到内存中，并移交控制权。QEMU自带的bootloader:OpenSBI固件。作为 bootloader 的 OpenSBI.bin 被加载到物理内存以物理地址 0x80000000 开头的区域上，同时内核镜像os.bin 被加载到以物理地址 0x80200000 开头的区域上。$\textcolor{red}{为何设置这个地址？}$
2. 驱动程序：CPU无法读取复杂读写的设备，需要借助驱动程序来读写，而这些驱动程序CPU要可以直接读取。
3. 固件:一种软件，它为设备的特定硬件提供低级控制。为设备更复杂的软件（如操作系统）提供标准化的操作环境。对于不太复杂的设备，固件可以直接充当设备的完整操作系统。例如OpenSBI。
4. 复位地址：在CPU上电或者按下复位键时，PC被赋予的初值。在本处理器中为0x80000000。内核的第一条指令位于0x80200000处。
5. 整体过程：
   1. 得到elf文件，并转换程bin文件。
   2. 操作系统二进制文件被openSBI加载到内存中。
   3. OPenSBI将pc跳转到某处开始执行指令

6. 代码解读
   1. 在链接脚本**kernel.ld**中，使用正则表达式筛选需要链接的代码以及数据。指定程序的入口点为kern_entry,此符号在**entry.S**文件中定义,在其中进行了栈的分配，然后采用尾递归调用(即$\textcolor{red}{跳转过后不再返回而是继续执行下去}$)调用了kern_init，这才是真正的入口点。
   2. kern_init:函数的定义在**init.c**文件中，由于刚刚提到了这是不返回的调用，于是在声明时采用**noreturn**的选项，在此此函数中用到了edata和end,由于在链接过程中定义，用到了extern关键字，使用自定义的memset将其中的数据初始化为0，这一点正满足了链接bss的格式要求。初始化后打印了一串字符，采用自定义的cprintf(),是自行实现的对打印单个字符串的封装。
   3. SBI提供了接口供我们使用:需要向其传入参数以及调用目的(putchar、timer等)。sbi_call中把参数传入对应寄存器中后，采用内联汇编调用ecall交给OpenSBI来执行，并把返回值拿回变量中来。使用如下参数可以实现读写字符串：
       
        ```c#
        uint64_t SBI_CONSOLE_PUTCHAR = 1;
        uint64_t SBI_CONSOLE_GETCHAR = 2;
        void sbi_console_putchar(unsigned char ch) {
        sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0); 
        }
        ```
    接下来在console.c中初步封装，再在stdio中进行完整实现，实现了三种不同的字符串读取:
    ```c
    static void cputch(int c, int *cnt)//1
    void cputchar(int c)//2 单个字符串，注意被强制转换
    int cputs(const char *str)//3 多个字符串，调用1和2
    ```

7. 上电到执行第一条指令分析：
   
   ![Alt text](<屏幕截图 2023-09-18 132226.png>)
   
   开始的第一条指令位置在0x1000:进行一系列计算，将t0的值变为0x80000000,然后跳转至该地址。在一直执行到0x80200000之间，进行内核的初始化操作，
   在到达0x80200000后开始执行第一条指令，之后进行初始化的操作：

   ![Alt text](<屏幕截图 2023-09-18 174336.png>)

   首先进行栈的初始化，然后执行到kern_entry，采用非尾递归调用进入kern_init函数并不再返回，即对应汇编代码中的：
   ```
   j 0x8020000c <kern_init>
   ```
   进入init.c，接下来执行如下：

   ![Alt text](<屏幕截图 2023-09-18 174336-1.png>)

   接下来几步通过step发现，调用的都是memset函数，在为其准备参数。将end存在a2中，edata存在a0中，0存在a1中，作为参数传入memset。

   ![Alt text](<屏幕截图 2023-09-18 184445.png>)

   继续步入，进入memset的内部，此时又跳转到string.c中执行memset函数，最后执行完毕返回s，并从刚才的下一条指令即0x80200028处开始执行。

   之后同理，为自己定义的cprintf()函数准备参数，然后跳转至函数定义处即stdio中执行代码，如下：

   ![Alt text](<屏幕截图 2023-09-18 190306.png>)
   ![Alt text](<屏幕截图 2023-09-18 190339.png>)

   接下来就像我们在第六点描述中的那样，解开一层一层的嵌套，进行字符串的打印操作。采用步过执行也可以发现按照我们的预期一条一套地在执行我们定义的函数，并且一直循环，直到一整句话被打印出来：中间结果如下图，可以看到，在调试的过程中已经打印出了THU三个字母。

  ![Alt text](<屏幕截图 2023-09-18 190732.png>)

   执行完毕后跳转回来，可以看到一直在0x8020003c处死循环执行。
